<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Tiro 2D</title>
    <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background-color: #121212; display: flex; justify-content: center; align-items: center; height: 100vh; color: #fff; font-family: Arial, sans-serif; }
    #game-container { position: relative; }
    #gameCanvas { background-color: #000; display: block; box-shadow: 0 0 40px #222; }
    #hud { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 8px; font-size: 16px; color: #fff; z-index: 2; }
    #player-health-bar { width: 200px; height: 18px; background: #333; border-radius: 8px; margin-bottom: 8px; overflow: hidden; }
    #player-health { height: 100%; background: linear-gradient(90deg, #0f0, #ff0, #f00); border-radius: 8px; transition: width 0.2s; }
    .hidden { display: none; }
    button { background-color: #f44336; color: #fff; padding: 10px 20px; border: none; cursor: pointer; font-size: 16px; border-radius: 5px; }
    button:hover { background-color: #d32f2f; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="hud">
            <div id="player-health-bar"><div id="player-health"></div></div>
            <div><b>Dicas:</b></div>
            <div>Movimento: Setas</div>
            <div>Atirar: Espaço</div>
            <div>Escudo: Z | Tiro Triplo: X | Turbo: C (após 20 abates)</div>
        </div>
        <div id="game-over" class="hidden">
            <h1>Fim de Jogo</h1>
            <p>Pontuação: <span id="final-score"></span></p>
            <div id="ranking"></div>
            <button id="restart-btn">Reiniciar</button>
            <button id="clear-ranking-btn">Limpar Ranking</button>
        </div>
    </div>
    <script>
// --- CONFIGURAÇÕES GERAIS ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = 800;
canvas.height = 600;

// --- FUNDO DE ESTRELAS ANIMADAS ---
const STAR_COUNT = 80;
const stars = Array.from({length: STAR_COUNT}, () => ({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    r: Math.random() * 1.5 + 0.5,
    speed: Math.random() * 0.7 + 0.2
}));
function drawStars() {
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = '#fff';
    for (const s of stars) {
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fill();
        s.y += s.speed;
        if (s.y > canvas.height) {
            s.x = Math.random() * canvas.width;
            s.y = 0;
            s.r = Math.random() * 1.5 + 0.5;
            s.speed = Math.random() * 0.7 + 0.2;
        }
    }
    ctx.restore();
}

// --- SONS BÁSICOS (com fallback) ---
function loadSound(src) {
    try { return new Audio(src); } catch { return { play:()=>{} }; }
}
const shootSound = loadSound('sounds/shoot.mp3');
const explosionSound = loadSound('sounds/explosion.mp3');
const shieldSound = loadSound('sounds/shield_activate.mp3');
const powerupSound = loadSound('sounds/powerup.mp3');

// --- RANKING LOCAL (localStorage) ---
function getRanking() {
    return JSON.parse(localStorage.getItem('ranking2d') || '[]');
}
function saveRanking(ranking) {
    localStorage.setItem('ranking2d', JSON.stringify(ranking));
}
function clearRanking() {
    localStorage.removeItem('ranking2d');
}

// --- CLASSE PRINCIPAL DO JOGO ---
class Game {
    constructor() {
        // --- VARIÁVEIS DE HISTÓRIA, ALIADOS E CONQUISTAS (fixas) ---
        this.storyDialogues = [
            { wave: 1, text: 'Ano 3024: A galáxia está sob ataque. Prepare-se, piloto da Aurora!' },
            { wave: 10, text: 'Primeira frota repelida! Mas há sinais de reforços inimigos...' },
            { wave: 20, text: 'Aliados detectados! Naves de apoio podem aparecer para ajudar.' },
            { wave: 30, text: 'Inimigos com escudos surgem. Fique atento aos padrões!' },
            { wave: 40, text: 'Aliados médicos podem curar você se forem resgatados.' },
            { wave: 50, text: 'Metade do caminho! Chefes duplos à frente.' },
            { wave: 60, text: 'Inimigos de elite detectados. Use suas habilidades com sabedoria.' },
            { wave: 80, text: 'Eventos estranhos: chuva de power-ups e blackout podem ocorrer.' },
            { wave: 100, text: 'Núcleo da invasão! Prepare-se para a batalha final contra a nave-mãe.' }
        ];
        this.init();
        this.setupListeners();
        this.loop();
    }
    addAchievement(desc) {
        if (!this.achievements.includes(desc)) {
            this.achievements.push(desc);
            this.showEventMessage('Conquista desbloqueada: ' + desc);
        }
    }
    showEventMessage(msg) {
        this.eventMessage = msg;
        this.eventTimer = 180;
    }
    spawnAlly(wave) {
        const types = [
            { type: 'gunner', color: '#0ff', desc: 'Aliado Atirador: tiros extras por 20s' },
            { type: 'medic', color: '#0f0', desc: 'Aliado Médico: cura 1 vida' },
            { type: 'shield', color: '#ff0', desc: 'Aliado Escudo: escudo global por 10s' },
            { type: 'bomb', color: '#f00', desc: 'Aliado Bomba: destrói todos os inimigos na tela' }
        ];
        const allyType = types[Math.floor(Math.random() * types.length)];
        this.allies.push({
            x: Math.random() * (canvas.width - 40),
            y: -40,
            width: 40,
            height: 40,
            speedY: 2,
            type: allyType.type,
            color: allyType.color,
            desc: allyType.desc,
            rescued: false
        });
    }
    // --- MÉTODOS DE JOGO ---
    init() {
        // Estado do jogador
        this.player = {
            x: canvas.width / 2 - 25,
            y: canvas.height - 70,
            width: 50,
            height: 50,
            speed: 7,
            canShoot: true,
            shootCooldown: 0,
            shootCooldownMax: 10,
            doubleShot: false,
            tripleShot: false,
            shield: false,
            maxLives: 3,
            blink: 0
        };
        // Estado do jogo
        this.bullets = [];
        this.enemies = [];
        this.meteors = [];
        this.boss = null;
        this.score = 0;
        this.lives = 3;
        this.kills = 0;
        this.gameOver = false;
        this.waveNumber = 1;
        this.enemiesPerWave = 3;
        this.waveCooldown = 180;
        this.waveTimer = 0;
        this.waveActive = true;
        this.animationId = null;
        this.meteorSpawnRate = 150;
        this.meteorSpawnCounter = 0;
        this.keys = { ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false, Space: false };
        this.skills = {
            shield: { active: false, duration: 600, timer: 0, cooldown: 1800, cooldownTimer: 0, unlocked: false },
            tripleShot: { active: false, duration: 900, timer: 0, cooldown: 1800, cooldownTimer: 0, unlocked: false },
            speedBoost: { active: false, duration: 600, timer: 0, cooldown: 1800, cooldownTimer: 0, unlocked: false }
        };
        // --- Aliados e conquistas e eventos ---
        this.achievements = [];
        this.eventMessage = '';
        this.eventTimer = 0;
        this.allies = [];
        this.allyActive = null;
        this.allyTimer = 0;
        this.currentDialogue = '';
        this.dialogueTimer = 0;
        this.storyWave = 0;
        this.eventActive = false;
    }
    setupListeners() {
        window.addEventListener('keydown', (e) => {
            if (e.key in this.keys) this.keys[e.key] = true;
            if (e.key === ' ' && this.player.canShoot) {
                this.createBullet();
                this.player.canShoot = false;
                this.player.shootCooldown = this.player.shootCooldownMax;
            }
            if (e.key === 'Enter' && this.gameOver) this.restart();
            if (!this.gameOver && this.kills >= 20) {
                if (e.key === 'z' || e.key === 'Z') this.activateSkill('shield');
                if (e.key === 'x' || e.key === 'X') this.activateSkill('tripleShot');
                if (e.key === 'c' || e.key === 'C') this.activateSkill('speedBoost');
            }
        });
        window.addEventListener('keyup', (e) => {
            if (e.key in this.keys) this.keys[e.key] = false;
        });
        document.getElementById('restart-btn')?.addEventListener('click', () => {
            if (this.gameOver) this.restart();
        });
        document.getElementById('clear-ranking-btn')?.addEventListener('click', () => {
            clearRanking();
            document.getElementById('ranking').innerHTML = '<h2>Ranking</h2><ol></ol>';
        });
    }
    createBullet() {
        shootSound.currentTime = 0; shootSound.play();
        const center = this.player.x + this.player.width / 2;
        if (this.player.tripleShot) {
            this.bullets.push({ x: center - 7.5, y: this.player.y, width: 5, height: 15, speed: 10, speedX: -2, color: '#0ff' });
            this.bullets.push({ x: center - 2.5, y: this.player.y, width: 5, height: 15, speed: 10, speedX: 0, color: '#0ff' });
            this.bullets.push({ x: center + 2.5, y: this.player.y, width: 5, height: 15, speed: 10, speedX: 2, color: '#0ff' });
        } else if (this.player.doubleShot) {
            this.bullets.push({ x: center - 7.5, y: this.player.y, width: 5, height: 15, speed: 10, color: '#ff0' });
            this.bullets.push({ x: center + 7.5, y: this.player.y, width: 5, height: 15, speed: 10, color: '#ff0' });
        } else {
            this.bullets.push({ x: center - 2.5, y: this.player.y, width: 5, height: 15, speed: 10, color: '#fff' });
        }
    }
    movePlayer() {
        if (this.keys.ArrowLeft) this.player.x -= this.player.speed;
        if (this.keys.ArrowRight) this.player.x += this.player.speed;
        if (this.keys.ArrowUp) this.player.y -= this.player.speed;
        if (this.keys.ArrowDown) this.player.y += this.player.speed;
        // Limites da tela
        if (this.player.x < 0) this.player.x = 0;
        if (this.player.x + this.player.width > canvas.width) this.player.x = canvas.width - this.player.width;
        if (this.player.y < 0) this.player.y = 0;
        if (this.player.y + this.player.height > canvas.height) this.player.y = canvas.height - this.player.height;
    }
    moveBullets() {
        this.bullets = this.bullets.filter(bullet => bullet.y + bullet.height > 0 && bullet.y < canvas.height && bullet.x + bullet.width > 0 && bullet.x < canvas.width);
        this.bullets.forEach(bullet => {
            if (bullet.isEnemyBullet) bullet.y += bullet.speed;
            else bullet.y -= bullet.speed;
            if (bullet.speedX) bullet.x += bullet.speedX;
        });
    }
    createEnemy() {
        const isSpecial = Math.random() < 0.2;
        const width = isSpecial ? 60 : 50;
        const height = isSpecial ? 60 : 50;
        const x = Math.random() * (canvas.width - width);
        if (isSpecial) {
            this.enemies.push({
                x: x, y: 0, width: width, height: height,
                speedX: (Math.random() - 0.5) * 3,
                speedY: Math.random() * 2 + 1.5,
                health: 3, special: true, shootCooldown: 60
            });
        } else {
            this.enemies.push({
                x: x, y: 0, width: width, height: height,
                speedX: (Math.random() - 0.5) * 2,
                speedY: Math.random() * 1.5 + 1,
                health: 1, special: false
            });
        }
    }
    moveEnemies() {
        this.enemies.forEach(enemy => {
            enemy.x += enemy.speedX;
            enemy.y += enemy.speedY;
            if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) enemy.speedX *= -1;
            if (enemy.special && enemy.shootCooldown !== undefined) {
                enemy.shootCooldown--;
                if (enemy.shootCooldown <= 0) {
                    this.bullets.push({
                        x: enemy.x + enemy.width / 2 - 5,
                        y: enemy.y + enemy.height,
                        width: 10, height: 20, speed: 6, isEnemyBullet: true
                    });
                    enemy.shootCooldown = 60;
                }
            }
        });
        const enemiesOnScreen = [];
        this.enemies.forEach(enemy => {
            if (enemy.y < canvas.height) {
                enemiesOnScreen.push(enemy);
            } else {
                this.lives--;
                explosionSound.currentTime = 0;
                explosionSound.play();
                if (this.lives <= 0) this.gameOver = true;
            }
        });
        this.enemies = enemiesOnScreen;
    }
    drawEnemies() {
        this.enemies.forEach(enemy => {
            const ex = enemy.x + enemy.width/2;
            const ey = enemy.y + enemy.height/2;
            ctx.save();
            ctx.translate(ex, ey);
            ctx.scale(1.1, 1.1);
            ctx.beginPath();
            ctx.moveTo(0, 18);
            ctx.lineTo(16, -18);
            ctx.lineTo(0, -8);
            ctx.lineTo(-16, -18);
            ctx.closePath();
            ctx.fillStyle = enemy.special ? 'orange' : 'red';
            ctx.shadowColor = enemy.special ? '#ff0' : '#f00';
            ctx.shadowBlur = 8;
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.beginPath();
            ctx.moveTo(0, 14);
            ctx.lineTo(5, -6);
            ctx.lineTo(-5, -6);
            ctx.closePath();
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.restore();
        });
    }
    createMeteor() {
        const size = 30 + Math.random() * 40;
        this.meteors.push({
            x: Math.random() * (canvas.width - size),
            y: -size,
            width: size,
            height: size,
            speedY: 2 + Math.random() * 3
        });
    }
    moveMeteors() {
        this.meteors.forEach(meteor => { meteor.y += meteor.speedY; });
        this.meteors = this.meteors.filter(meteor => meteor.y < canvas.height);
    }
    drawMeteors() {
        ctx.fillStyle = 'gray';
        this.meteors.forEach(meteor => {
            ctx.beginPath();
            ctx.arc(meteor.x + meteor.width / 2, meteor.y + meteor.height / 2, meteor.width / 2, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    createBoss() {
        this.boss = {
            x: canvas.width / 2 - 100,
            y: 50,
            width: 200,
            height: 100,
            speedX: 3,
            health: 50,
            shootCooldown: 40,
            shootCooldownMax: 40
        };
    }
    moveBoss() {
        if (!this.boss) return;
        this.boss.shootCooldown--;
        this.boss.x += this.boss.speedX;
        if (this.boss.x <= 0 || this.boss.x + this.boss.width >= canvas.width) this.boss.speedX *= -1;
        if (this.boss.shootCooldown <= 0) {
            this.bullets.push({ x: this.boss.x + this.boss.width / 2 - 5, y: this.boss.y + this.boss.height, width: 10, height: 20, speed: 7, isEnemyBullet: true });
            this.bullets.push({ x: this.boss.x + 30, y: this.boss.y + this.boss.height, width: 10, height: 20, speed: 7, speedX: -2, isEnemyBullet: true });
            this.bullets.push({ x: this.boss.x + this.boss.width - 40, y: this.boss.y + this.boss.height, width: 10, height: 20, speed: 7, speedX: 2, isEnemyBullet: true });
            this.boss.shootCooldown = this.boss.shootCooldownMax;
        }
    }
    drawBoss() {
        if (!this.boss) return;
        ctx.save();
        ctx.translate(this.boss.x + this.boss.width/2, this.boss.y + this.boss.height/2);
        ctx.scale(2, 1.2);
        ctx.beginPath();
        ctx.moveTo(0, -40);
        ctx.bezierCurveTo(60, -20, 60, 40, 0, 40);
        ctx.bezierCurveTo(-60, 40, -60, -20, 0, -40);
        ctx.closePath();
        ctx.fillStyle = 'purple';
        ctx.shadowColor = '#a0f';
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.ellipse(0, 0, 18, 28, 0, 0, Math.PI*2);
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.3;
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.restore();
        ctx.fillStyle = 'red';
        ctx.fillRect(this.boss.x, this.boss.y - 10, this.boss.width * (this.boss.health / 50), 5);
    }
    updateSkills() {
        for (const skillName in this.skills) {
            const skill = this.skills[skillName];
            if (skill.active) {
                skill.timer--;
                if (skill.timer <= 0) {
                    skill.active = false;
                    if (skillName === 'shield') this.player.shield = false;
                    if (skillName === 'speedBoost') this.player.speed /= 1.5;
                    if (skillName === 'tripleShot') this.player.tripleShot = false;
                }
            }
            if (skill.cooldownTimer > 0) skill.cooldownTimer--;
        }
    }
    checkCollisions() {
        const survivingBullets = [];
        this.bullets.forEach(bullet => {
            let hitSomething = false;
            if (bullet.isEnemyBullet) {
                if (this.isColliding(bullet, this.player)) {
                    if (!this.player.shield) {
                        this.lives--;
                        this.player.blink = 10;
                        explosionSound.currentTime = 0;
                        explosionSound.play();
                        if (this.lives <= 0) this.gameOver = true;
                    }
                    hitSomething = true;
                } else {
                    survivingBullets.push(bullet);
                }
            } else {
                let hitEnemy = false;
                this.enemies = this.enemies.filter(enemy => {
                    if (this.isColliding(bullet, enemy)) {
                        this.score += 10;
                        this.kills++;
                        explosionSound.currentTime = 0;
                        explosionSound.play();
                        hitEnemy = true;
                        return false;
                    }
                    return true;
                });
                if (this.boss && this.isColliding(bullet, this.boss)) {
                    this.boss.health--;
                    this.score += 20;
                    this.kills++;
                    explosionSound.currentTime = 0;
                    explosionSound.play();
                    hitEnemy = true;
                    if (this.boss.health <= 0) {
                        this.boss = null;
                        this.player.doubleShot = true;
                        this.waveActive = true;
                        this.waveTimer = this.waveCooldown;
                        powerupSound.currentTime = 0;
                        powerupSound.play();
                        setTimeout(() => { this.player.doubleShot = false; }, 20000);
                    }
                }
                if (!hitEnemy) {
                    survivingBullets.push(bullet);
                } else {
                    hitSomething = true;
                }
            }
        });
        this.bullets = survivingBullets;
        this.enemies = this.enemies.filter(enemy => {
            const collided = this.isColliding(this.player, enemy);
            if (collided) {
                if (!this.player.shield) {
                    this.lives--;
                    this.player.blink = 10;
                    explosionSound.currentTime = 0;
                    explosionSound.play();
                    if (this.lives <= 0) this.gameOver = true;
                }
                return false;
            }
            return true;
        });
        this.meteors = this.meteors.filter(meteor => {
            const collided = this.isColliding(this.player, meteor);
            if (collided) {
                if (!this.player.shield) {
                    this.lives--;
                    this.player.blink = 10;
                    explosionSound.currentTime = 0;
                    explosionSound.play();
                    if (this.lives <= 0) this.gameOver = true;
                }
                return false;
            }
            return true;
        });
    }
    isColliding(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
            rect1.x + rect1.width > rect2.x &&
            rect1.y < rect2.y + rect2.height &&
            rect1.y + rect1.height > rect2.y;
    }
    drawScore() {
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.fillText('Pontuação: ' + this.score, 10, 30);
        ctx.fillText('Vidas: ' + this.lives, 10, 60);
        ctx.fillText('Abates: ' + this.kills, 10, 90);
        ctx.fillText('Onda: ' + this.waveNumber, 10, 120);
        let y = 150;
        for (const skillName in this.skills) {
            const skill = this.skills[skillName];
            let text = '';
            if (skill.active) {
                text = `${skillName.toUpperCase()} ATIVO (${Math.ceil(skill.timer / 60)}s)`;
            } else if (skill.cooldownTimer > 0) {
                text = `${skillName.toUpperCase()} CD: ${Math.ceil(skill.cooldownTimer / 60)}s`;
            } else if (this.kills >= 20) {
                text = `${skillName.toUpperCase()} PRONTO (tecla ${skillName === 'shield' ? 'Z' : skillName === 'tripleShot' ? 'X' : 'C'})`;
            } else {
                text = `${skillName.toUpperCase()} BLOQUEADO (20 abates)`;
            }
            ctx.fillText(text, 10, y);
            y += 30;
        }
    }
    drawPlayer() {
        if (this.player.shield) {
            ctx.save();
            ctx.globalAlpha = 0.5 + 0.5 * Math.sin(Date.now()/100);
            ctx.strokeStyle = 'cyan';
            ctx.lineWidth = 7;
            ctx.beginPath();
            ctx.arc(this.player.x + this.player.width / 2, this.player.y + this.player.height / 2, this.player.width, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
        if (this.player.blink > 0) {
            ctx.save();
            ctx.globalAlpha = 0.3 + 0.7 * Math.sin(Date.now()/50);
        }
        const px = this.player.x + this.player.width/2;
        const py = this.player.y + this.player.height/2;
        ctx.save();
        ctx.translate(px, py);
        ctx.scale(1.2, 1.2);
        ctx.beginPath();
        ctx.moveTo(0, -22);
        ctx.lineTo(16, 18);
        ctx.lineTo(0, 10);
        ctx.lineTo(-16, 18);
        ctx.closePath();
        ctx.fillStyle = 'lime';
        ctx.shadowColor = '#0f0';
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.moveTo(0, -18);
        ctx.lineTo(4, 8);
        ctx.lineTo(-4, 8);
        ctx.closePath();
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.restore();
        if (this.player.blink > 0) ctx.restore();
    }
    gameOverScreen() {
        document.getElementById('final-score').innerText = this.score;
        // Salva pontuação no ranking
        let ranking = getRanking();
        ranking.push(this.score);
        ranking.sort((a, b) => b - a);
        ranking = ranking.slice(0, 5);
        saveRanking(ranking);
        // Exibe ranking
        let html = '<h2>Ranking</h2><ol>';
        for (let i = 0; i < ranking.length; i++) {
            html += `<li>${ranking[i]} pontos</li>`;
        }
        html += '</ol>';
        document.getElementById('ranking').innerHTML = html;
        document.getElementById('game-over').classList.remove('hidden');
    }
    restart() {
        this.init();
        document.getElementById('game-over').classList.add('hidden');
        if (this.animationId) cancelAnimationFrame(this.animationId);
        this.loop();
    }
    activateSkill(skillName) {
        const skill = this.skills[skillName];
        if (!skill.unlocked) skill.unlocked = true;
        if (skill.cooldownTimer <= 0 && !skill.active) {
            skill.active = true;
            skill.timer = skill.duration;
            skill.cooldownTimer = skill.cooldown + skill.duration;
            if (skillName === 'shield') {
                this.player.shield = true;
                shieldSound.currentTime = 0;
                shieldSound.play();
            }
            if (skillName === 'speedBoost') this.player.speed *= 1.5;
            if (skillName === 'tripleShot') this.player.tripleShot = true;
        }
    }
    // --- LOOP PRINCIPAL ---
    loop() {
        if (this.gameOver) {
            this.gameOverScreen();
            return;
        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawStars();
        // --- História e eventos ---
        if (this.storyDialogues.length && this.waveNumber !== this.storyWave) {
            const found = this.storyDialogues.find(d => d.wave === this.waveNumber);
            if (found) {
                this.currentDialogue = found.text;
                this.dialogueTimer = 300;
                this.storyWave = this.waveNumber;
            }
        }
        if (this.dialogueTimer > 0) this.dialogueTimer--;
        if (this.eventTimer > 0) this.eventTimer--;
        // --- Eventos aleatórios ---
        if (this.waveNumber >= 30 && Math.random() < 0.0007 && !this.eventActive) {
            this.showEventMessage('Chuva de power-ups!');
            for (let i = 0; i < 3; i++) this.spawnAlly(this.waveNumber);
            this.eventActive = true;
            setTimeout(()=>{this.eventActive=false;}, 5000);
        }
        if (this.waveNumber >= 80 && Math.random() < 0.0005 && !this.eventActive) {
            this.showEventMessage('Blackout! Visibilidade reduzida por 5s');
            ctx.save();
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = '#000';
            ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.restore();
            this.eventActive = true;
            setTimeout(()=>{this.eventActive=false;}, 5000);
        }
        this.movePlayer();
        if (!this.player.canShoot) {
            this.player.shootCooldown--;
            if (this.player.shootCooldown <= 0) this.player.canShoot = true;
        }
        if (this.player.blink > 0) this.player.blink--;
        // Atualiza barra de vida
        const healthBar = document.getElementById('player-health');
        healthBar.style.width = (100 * this.lives / this.player.maxLives) + '%';
        if (this.player.blink > 0) healthBar.style.background = '#f00';
        else healthBar.style.background = 'linear-gradient(90deg, #0f0, #ff0, #f00)';
        this.moveBullets();
        this.moveEnemies();
        this.moveMeteors();
        this.moveBoss();
        this.meteorSpawnCounter++;
        if (this.meteorSpawnCounter >= this.meteorSpawnRate) {
            this.createMeteor();
            this.meteorSpawnCounter = 0;
        }
        // --- Aliados ---
        if (this.waveNumber >= 20 && Math.random() < 0.002 && this.allies.length < 2) {
            this.spawnAlly(this.waveNumber);
        }
        this.moveAllies();
        this.checkAllyRescue();
        if (!this.boss && this.waveActive) {
            if (this.enemies.length === 0 && this.waveTimer <= 0) {
                for (let i = 0; i < this.enemiesPerWave; i++) this.createEnemy();
                this.waveActive = false;
                this.waveTimer = this.waveCooldown;
            }
        } else if (this.waveTimer > 0) {
            this.waveTimer--;
            if (this.waveTimer <= 0) {
                this.waveNumber++;
                this.enemiesPerWave = Math.max(3, this.enemiesPerWave + 1);
                this.waveActive = true;
            }
        }
        // Boss a cada 5 ondas
        if (this.waveNumber % 5 === 0 && !this.boss && this.enemies.length === 0) {
            this.createBoss();
            this.waveActive = false;
        }
        this.checkCollisions();
        this.updateSkills();
        this.drawPlayer();
        this.drawBullets();
        this.drawEnemies();
        this.drawMeteors();
        this.drawBoss();
        this.drawAllies();
        this.drawScore();
        this.drawEventMessage();
        this.drawStoryDialogue();
        this.drawAchievements();
        this.animationId = requestAnimationFrame(() => this.loop());
    }
    moveAllies() {
        for (const ally of this.allies) {
            ally.y += ally.speedY;
        }
        // Remove aliados fora da tela
        for (let i = this.allies.length - 1; i >= 0; i--) {
            if (this.allies[i].y > canvas.height) this.allies.splice(i, 1);
        }
    }
    drawAllies() {
        for (const ally of this.allies) {
            ctx.save();
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = ally.color;
            ctx.beginPath();
            ctx.arc(ally.x + ally.width/2, ally.y + ally.height/2, 18, 0, Math.PI*2);
            ctx.fill();
            ctx.font = '12px Arial';
            ctx.fillStyle = '#222';
            ctx.fillText(ally.type.toUpperCase(), ally.x+2, ally.y+ally.height/2+4);
            ctx.restore();
        }
    }
    checkAllyRescue() {
        for (let i = this.allies.length - 1; i >= 0; i--) {
            const ally = this.allies[i];
            if (!ally.rescued && this.isColliding(this.player, ally)) {
                this.activateAlly(ally);
                this.addAchievement('Resgatou um aliado: ' + ally.type);
                this.showEventMessage(ally.desc);
                ally.rescued = true;
                this.allies.splice(i, 1);
            }
        }
    }
    activateAlly(ally) {
        if (ally.type === 'gunner') {
            this.allyActive = 'gunner';
            this.allyTimer = 1200;
        } else if (ally.type === 'medic') {
            this.lives = Math.min(this.lives + 1, this.player.maxLives);
        } else if (ally.type === 'shield') {
            this.skills.shield.active = true;
            this.skills.shield.timer = 600;
            this.player.shield = true;
        } else if (ally.type === 'bomb') {
            this.enemies = [];
            this.meteors = [];
        }
    }
    drawEventMessage() {
        if (this.eventTimer > 0) {
            ctx.save();
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = '#222';
            ctx.fillRect(canvas.width/2-180, 60, 360, 40);
            ctx.font = '20px Arial';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText(this.eventMessage, canvas.width/2, 90);
            ctx.textAlign = 'left';
            ctx.restore();
        }
    }
    drawStoryDialogue() {
        if (this.dialogueTimer > 0 && this.currentDialogue) {
            ctx.save();
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = '#111';
            ctx.fillRect(canvas.width/2-220, canvas.height-80, 440, 40);
            ctx.font = '18px Arial';
            ctx.fillStyle = '#0ff';
            ctx.textAlign = 'center';
            ctx.fillText(this.currentDialogue, canvas.width/2, canvas.height-50);
            ctx.textAlign = 'left';
            ctx.restore();
        }
    }
    drawAchievements() {
        ctx.save();
        ctx.font = '14px Arial';
        ctx.fillStyle = '#ff0';
        for (let i = 0; i < Math.min(this.achievements.length, 4); i++) {
            ctx.fillText('🏆 ' + this.achievements[i], canvas.width-320, 40 + i*22);
        }
        ctx.restore();
    }
    drawBullets() {
        this.bullets.forEach(bullet => {
            ctx.fillStyle = bullet.color || 'cyan';
            ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        });
    }
}
// --- INICIAR O JOGO ---
new Game();

window.addEventListener('DOMContentLoaded', () => {
    const gameOverDiv = document.getElementById('game-over');
    if (gameOverDiv && !document.getElementById('clear-ranking-btn')) {
        const btn = document.createElement('button');
        btn.id = 'clear-ranking-btn';
        btn.textContent = 'Limpar Ranking';
        btn.style.marginLeft = '10px';
        btn.onclick = () => {
            clearRanking();
            document.getElementById('ranking').innerHTML = '<h2>Ranking</h2><ol></ol>';
        };
        gameOverDiv.appendChild(btn);
    }
});
    </script>
</body>
</html>
